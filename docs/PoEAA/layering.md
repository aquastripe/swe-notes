# 分層

分層是軟體設計人員用來分解複雜系統的常用技術之一。例如：FTP 建構在 TCP 之上，TCP 建構在 IP 之上，IP 建構在乙太網路之上。以階層的角度來思考系統時，上層使用下層的各種服務，而下層對上層隱藏實作細節。

將系統分層的優點是：

- 不需要對其他階層有過多的了解，可以把單一階層當成一個連貫的整體來理解。
- 可以在提供相同服務時，替換某個階層的實作。
- 可以最小化階層之間的依賴關係。
- 分層有利於標準化工作。
- 建構好階層後，就可以用它來為更多更高層次的服務提供支援。

缺點：

- 分層能封裝一些東西，但不是所有東西。例如：如果需要在 UI 上面顯示一個新增欄位，那麼該欄位的值就必須被儲存在資料庫裡面；因此需要在 UI 到資料庫之間的所有階層加入這個欄位的資訊。
- 過多的分層會減損效能。分層通常需要轉換資料表達形式。不過通常底層封裝的效益大於代價。

分層架構最困難的是如何決定要建立哪些階層，還有每個階層的責任是什麼。

## 分層的演進

1. 早期：撰寫 ISAM、VSAM 形式的程式，不需要分層。
2. 用戶端/伺服器系統出現，分層的概念變得明顯。這時候分為兩層：用戶端包含使用者介面和其他應用程式碼，伺服器端通常是關聯式資料庫。常見的工具是 VB、Powerbuilder、Delphi。這些工具使得建置資料密集型的應用程式變得特別容易，因為這些 UI 元件具有理解 SQL 的能力。開發人員會把領域邏輯 (domain logic) 嵌入 UI 畫面中來完成工作，使得當領域邏輯越來越複雜時，程式碼也越來越難以使用。
3. 一種替代方案是將領域邏輯以預存程序　(stored procedure) 的方式存放在資料庫。然而，預存程序只提供了有限的資料結構，而且預存程序是資料庫供應商專有的，使得使用了預存程序以後將無法更換資料庫供應商。
4. 物件導向社群對於領域邏輯的解決方案是三層式系統：UI 展示層、領域邏輯的領域層、資料存取層。不過物件導向的浪潮並沒有取得太大的進展。雖然這種三層式的架構有很大的優點，不過如果系統很簡單時，用戶端/伺服器的架構還是比較有吸引力，但這個架構很難套用在三層式系統的設定上。
5. Web 的興起帶來巨大的衝擊。人們突然想在 Web 瀏覽器上面部署這些用戶端/伺服器的應用程式。如果要將所有商業邏輯都埋在一個有豐富效果的用戶端上，則需要再 Web 介面重新開發所有商業邏輯。一個設計良好的三層式系統只需要加入一個新的展示層，然後用它來完成新的 Web 介面就好。Java 的出現也使得物件導向語言向當時的主流造成衝擊。用來建置 Web 頁面的工具和 SQL 之間的關聯也沒那麼高了，因此適合導入三層式架構。

### Layer/Tier 的誤用

Tier 指的是實體的分離，例如用戶端/伺服器的應用程式通常被稱為雙層系統 (two-tier system)。Layer 則是可以在同一台機器上面運作。

## 三個主要分層


| 分層                   | 職責        |
| -------------------- | --------- |
| 展示層 (presentation)   | 提供服務、顯示資訊 |
| 領域邏輯層 (domain logic) |           |
| 資料來源層 (data source)  | 與其他系統通訊   |

如果沒有使用者驅動軟體: 展示層和資料來源層有很多相似之處。例如： [Alistair Cockburn 六角架構模式 (Hexagonal Architecture pattern)](https://alistair.cockburn.us/hexagonal-architecture/)，將任何系統都當作一個核心，而這個核心被外部系統包圍。這是一種對稱視角 (symmetrical view)，而非本書內的反對稱分層 (asymmetric layering scheme)。

![](https://alistair.cockburn.us/wp-content/uploads/2018/02/Hexagonal-architecture-basic-1.gif)

非對稱性的好處： **向他人提供服務的介面** 與 **你使用他人服務的介面** 有個很好的區別。

- 展示層是系統為他人提供服務的外部介面，無論他人是人類或是簡單的系統
- 資料來源層是為你提供服務的介面

雖然可以為每個系統都如此分三層，不過如何分層還是要看系統的複雜性。

- 最簡單的系統可能只是單檔程式，不過還是可以努力分離職責，比如分成三個子程序
- 複雜度更高一些時，可以分離到類別
- 在更複雜時，可以把類別分離成套件

依賴關係的可靠性原則： **領域邏輯層** 和 **資料來源層** 不要依賴於 **展示層**。

領域邏輯層的困難：難以分辨什麼是領域邏輯。一個非正式的測試方法：請想像對系統加入一個完全不同的分層。例如：

- 為 Web 應用程式加入一個命令列介面，看看是否需要重複實作任何功能才能完成。
- 是否需要重複實作某些邏輯，才能用 XML 檔案取代使用關聯式資料庫。

作者對這個過於教條式的做法感到不安

> Alan Knight 在校稿時評論：「感到困惑的是，將領域邏輯放入 UI 中，究竟是走向災難的一步，還是一個合情合理的作法，只有純粹主義者 (dogmatic purist) 才會反對？」

不安的原因是兩者皆是。

## 選擇分層的運作地點

首先決定：應用程式在哪裡運作？客戶端、桌電、伺服器？

- 在伺服器上運作所有服務，然後用瀏覽器存取。
  - 伺服器被侷限在一處，容易維護。
  - 不用擔心如何部署到多個客戶端、如何同步伺服器。
  - 相容性好。
- 在用戶端運作：
  - 系統回應能力好。
  - 沒有網路情況下可以運作。

接著就可以逐層分析：

- 資料來源層：通常都在伺服器，例外狀況是需要離線作業時。
- 展示層：是否需要豐富的 UI 效果？
- 領域邏輯層：在客戶端或伺服器運作都可以。運作在伺服器上有助於維護，在客戶端上有助於回應能力。
    - 在客戶端上運作：可以考慮運作所有邏輯，確保都在同個地方。問題：升級和維護成本很高。
    - 分散到客戶端和伺服器端上運作：很難知道邏輯放在哪個地方。解決辦法：將少量邏輯隔離在一個獨立的容器模組裡面，此模組不依賴任何系統。如此就能在客戶端或伺服器運作此模組。

除非不得已，不要分離分層並放到多個處理程序中執行，否則會降低效能又增加複雜性。以下許多因素都是 Jens Coldewey 所說的複雜性助推器 (complexity booster):

- 分散式
- 多執行緒
- 典範鴻溝 (paradigm chasms)
- 多平台開發
- 高效能需求
